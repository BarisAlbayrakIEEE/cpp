/// <summary>
/// 
/// CAUTION:
///     THIS REPOSITORY IS CREATED TO SHOW SOME OF MY C++ CAPABILITIES FOR JOB APPLICATIONS
/// 
/// 
/// 
/// SUMMARY:
/// THIS REPOSITORY CONTAINS THREE SOLUTIONS FOR A PRIMITIVE GEOMETRY LIBRARY:
///     1. GeometryLibrary_OCCT:
///         The solution mainly with C++98 although some of C++11 futures are used
///         See the readme file (or the docstring of the GeometryObject header file) in GeometryLibrary_OCCT
///     2. GeometryLibrary_CPP11:
///         The solution with C++11 and C++14
///         See below with heading 'A. GeometryLibrary_CPP11'
///     3. GeometryLibrary_MultiThread:
///         An updated version of GeometryLibrary_CPP11 to cover a solution supporting the multi threading.
///         See the readme file (or the docstring of the GeometryObject header file) in GeometryLibrary_MultiThread
///         Implementation process started recently.
/// 
/// CAUTION:
///     GeometryLibrary_OCCT is a quite old version created at the beginning of this project.
///     Updates made on the GeometryLibrary_CPP11 have rarely been reflected on that item (GeometryLibrary_OCCT).
///     The worst is that even any update is applied, the updated function has not been unit tested.
///     Hence, the code is not stable currently.
///     However, the aim of that library was basicaly to examine C++98 features
///     especially the smart pointers generated by the developers (OCCT Standard_Handle class) with C++98.
///     A comparison of C++98 smart pointers with the C++11 standards (std::shared_ptr and std::unique_ptr)
///     will be reported in the FUTURE.
/// 
/// THE DESCRIPTIONS ABOUT THE LIBRARY IS BELOW WITH HEADING 'B. DEFINITION OF THE GEOMETRY LIBRARY'
/// 
/// 
/// 
/// A. GeometryLibrary_CPP11
/// 
/// The main purpose of this library is to introduce C++11 and later semantics into Geometry Library.
/// Followings are the key points for this library:
///     1. Class/function invariants and preconditions are analyzed in detail.
///        Header file docstrings decribe the class invariants
///        and docstrings of some of the functions (e.g. Circle::Circle(Point3D thePoint0, Point3D thePoint1, Point3D thePoint2))
///        also describe the invariants and preconditions.
///        Exception definitions (and RAII) follow the invariants and preconditions.
/// 
///        For example, points and vectors are the invariants of axes and planes in the library.
///        In GeometryLibrary_OCCT, these classes also stores the Equation Coefficients (EC)
///        which are derived from the passing point and direction/normal vector.
///        This causes four problems:
///            1. Data duplication
///            2. More complexity is introduced into the exception determination
///            3. Increased code complexity
///            4. Increased side effects
///        Hence, in GeometryLibrary_CPP11, EC values are not stored as a member anymore
///        but are calculated and returned when requested.
///     2. Rule of Zero is applied to all classes
///        accept for GeometryObject base class having a user defined special functions
///        due to the incrementation and decrementation requirement of the static ID counter.
///        An important discussion related to this issue is GlobalCoordSystem class.
///        The discussion is quite long, hence, refer to the docstring of GlobalCoordSystem header file.
///     3. Resource management to achieve RAII is based on the smart pointers.
///        The new operator is used only once in GlobalCoordSystem singleton static function
///        together with the shared pointer constructor.
///        The library does not use resources like I/O streams.
///        However, speccial data structures (containers) for the library are CURRENTLY under construction.
///        
///        In order to have a well-established code in terms of RAII,
///        a strong guarantee for the exception safety is required to eliminate all memory leaks
///        which is CURRENTLY not supported with GeometryLibrary_CPP11.
///        The reason for this situation is that
///        the library does not deal with significant resources (excluding the containers being impelemted):
///            std::string, std::array and std::vector are used with a very small size.
///        For example, the point coordinates are stored in a std::array with 3 elements.
/// 
///        Some of the operations on the data structures (e.g. extending the data structure) throw exception.
///        Hence, the functions dealing with the containers being implemented shall be designed to supply
///        at least the strong exception guarantee.
///        More detailed study for each function to have a strong exception gurantee WILL BE PERFORMED.
///        Additionally, tools like Copy & Swap idiom will also be utilized
///        especially for the special functions to improve the thread safety together with the exception safety.
///        
///        Another point, which comes with the ownership issue, is the parametric design of a geometry library.
///        Most of the CAE tools (e.g. Catia) support parametric design.
///        Consider, a line defined by two points.
///        Consider one of the points is updated.
///            1. Parametric Framework (Catia): Updates the line accordingly
///               Actually, the data of the line is not updated.
///               Only, the visual representation of the line on the GUI is updated.
///            2. Non-parametric Framework (MSC.PATRAN): Does not update the line.
///        The reason of the above results is as follows:
///            1. Parametric Framework (Catia): Line object is defined by two point objects
///               Hence, the line is updated when points are updated.
///            2. Non-parametric Framework (MSC.PATRAN): Line object is defined by numeric data.
///               When the ctor of the line object is called with two points
///               the ctor calculates the required parameters to define the line by two points
///               and stores these numeric data into the new object instead of the points.
///               Hence, the line object and the point objects are independent.
///        Hence, the object ownership is crutial in order to have a parametric geometry library.
///     4. Shared ownership is implemented on all objects in the library via std::shared_ptr.
///        For example, a Line object has ownership on two Point3D objects through c_endPoint0 and c_endPoint1 members.
///        These point objects may be owned by other objects (e.g. an Axis object or another Line object).
///        
///        Exclusive ownership (std::unique_ptr) is not considered relevant for the implementation of Geometry Library.
///        Weak pointers (std::weak_ptr) are either not used.
///        An application of the weak pointers would be to count the shared ownership on an object.
///        This is actually required:
///            Consider a user of the final product (i.e. the GUI) wants to delete a point.
///            The forced delete operation by the user shall be canceled if any object has an ownership on that point.
///            Weak pointers could be utilized in this respect.
///            THIS SITUATION WILL BE STUDIED DETAILY IN THE FUTURE.
///            Currently, weak pointers are not used to save memory
///            Besides, a more optimistic solution (a special data structure?) can be determined.
/// 
///        Smart pointers are used in function arguments in order to transfer ownership into the function.
///        If ownership transfer is not required,
///        the traditional const reference approach (const Type&) is followed.
///     5. The side effects must be considered together with the exception safety and memory leaks
///        as they may cause problems to achieve at least a strong exception guarantee.
///        Followings are some of the sources of the side effects in this library.
///        and will be studied in more detail during GeometryLibrary_MultiThread implementation: 
///            1. Some of the constructors, copy constructors and assignments.
///               For example, Circle constructor by 3 points
///               creates a Point object as the center point and a Plane object as the reference plane.
///            2. The containers currently being implemented are another source of side effects
///               as any GeometryObject creation must update a container respectively
///               accept for the temporary objects.
///               Even the object creation is delegated to a factory located in the containers,
///               the copy constructors and operators of the GeometryObjects
///               will still cause side effects.
///            3. The static counter for the GeometryObjects (GeometryObject::c_IDCounter).
///               The counter is incremented when a GeometryObject is created
///               and decremented when destructed.
///               Both actions are side effects but the decrement operation is more problematic.
///               See below with CAUTION FOR STATIC ID COUNTER heading for the details.
///               The side effect in the destructor can be defeated
///               by removing the decrement in the GeometryObjects destructor
///               and letting it to have large values.
///               But, this is not preferable
///               as the ID member of GeometryObjects is used for the container hashing
///               and large values will reduce the effectivity of the hash function.
///            4. As specified before, the Equation Coefficients (EC) members of Axis and Plane objects
///               of GeometryLibrary_OCCT are removed in GeometryLibrary_CPP11.
///               Similarly, magnitude and length members of Vector and Line objects respectively are also removed.
///               All of these members cause side effects
///               as the setter methods of these classes must also modify one of these members
///               together with the actual member to be set.
///               The fundamental rule requires a unique setter for each member.
///               Hence, these inter-related members are all removed.
///            5. Some of the setters has side effects too.
///               Consider a Line object with two points
///               The points by definition of a line cannot be coincident
///               which is inspecteed during the construction of the line objects.
///               Let's consider we modified the location of one of the points.
///               As a result, the line object will also modified PHYSICALLY.
///               However, the state of the line object is not changed,
///               as we removed the length member from Line class.
///               The line is still the same pointing to the same two points.
///               However, another condition exists.
///               Lets consider we relocated the point where the other point exists.
///               Now, the line becomes exceptional.
///               We CURRENTLY cannot prevent this relocation
///               as we do not inspect all objects sharing the ownership of an object
///               when the object is modified.
///               Hence, the coordinate setter of Point class has side effects.
///            6. Many people consider that, for C++, the exceptions are side effects,
///               as C++ does not have exception specification in the function definition (e.g. Java).
///               The clients are not constrained to take the required action
///               when an exception is thrown by the called function.
///               Hence, the exception may not be considered to fulfill its duty
///               to convert our partial function into a total function.
/// 
///               The library contains many functions, even ctors, throwing.
///               These functions may all be considered to have side effects.
///     6. Template and auto type deductions are CURRENTLY studied carefully.
///        The initializer lists are not used together with auto types to simplify initializer list initializations.
///        Both of the C++11 and C++14 type deduced function declarations are used
///            C++11: auto identifier(args...) -> return_type
///            C++14: auto identifier(args...)  OR  decltype(auto) identifier(args...)
///     7. Rvalue references are considered (if reasonable) together with the lvalue references for optimization.
///        However, this library rarely has a separate function for the rvalue reference argument
///            Ex: GeometryObject::setName(std::string&& theName)
/// 
///        Instead, mostly, universal references are used.
///            Ex: In Vector2D:
///                auto add(T&& theVector) const
///                ->std::shared_ptr<typename std::remove_const_t<std::remove_reference_t<decltype(theVector)>>>;
///        Many functions rely on the universal references.
///        A fundamental problem with the rvalue references is
///        a result of the template type deduction together with the explicit constructors.
///        For example, consider the above example (Vector2D::add(T&&)).
///        Lets consider if the function has been defined with a universal reference.
///        That template function would firstly inspect if the base type of the input parameter is VectorBase.
///        Both Vector2D and Vector3D are acceptable.
///        And both have explicit ctors with a std::array<double, 3>.
///        Hence, in the client code, the compiler could not distinguish the type deduction
///        for an rvalue std::array<double, 3> input to the add template function.
///        It is realy hard to determine the cause of such a compiler error for a client developer.
///        
///        Keep in mind that, despite of having a similar functionality,
///        GeometryObject::Clone, does not use universal reference for the input argument
///        as it does not make sence to clone a temporary object.
///     8. Copy elision, RVO and NRVO studied carefully.
///        Most of the time, even standards on the issue differ between C++11 and C++17,
///        leaving the optimization to the compiler is mostly more efficient.
///        Explicit actions blocking the copy elision, RVO and NRVO has held only in a few locations:
///            returning an rvalue reference with std::move
///            returning a universal reference with std::forward
///            returning with a trinary operator
///     9. C++98 enums used in GeometryLibrary_OCCT are still in use in this library (GeometryLibrary_CPP11)
///        as a quite long time is required to update
///        the library for the new enum class of C++11
///        because enum variables are used in too many locations as integer variables.
///    10. The source files (e.g. Axis.cxx) includes all headers
///        and the header files are include guarded (i.e. #ifndef directive).
///        This is the current strategy which is quite easy to compile the library without linking errors.
///        However, this approach creates too much code at the end of the preprocess
///        due to the inclusion of all headers some of which are redundant for the source file.
///        The header file include directives will be rearranged for each source file ASAP.
///    11. The interface base class ReferenceAbstractObject in GeometryLibrary_OCCT
///        is removed to have a simple class hyerarchy as it was totally redundant.
///    12. Protected class members in GeometryLibrary_OCCT is made private in this library for encapsulation.
///        As is well known, protected variables are accessible by just simple inheritance
///        and this breaks LSP (Liskov Substitution Principle), OCP (Open-Closed Principle).
/// 
/// 
/// 
/// B. DEFINITION OF THE GEOMETRY LIBRARY:
/// 
/// This library is a primitive geometry library
/// which enables 2D to 3D (or vice versa) switch.
/// Contains the fundamental variables only:
/// Coord Systems (CS), a unique global CS, points, vectors, axes, lines, circles and planes.
/// Points and vectors are ReferenceObject types which are defined wrt a CS.
/// ReferenceObject instances can be 2D or 3D whereas the other types (e.g. an axis or plane)
/// are default 3D objects.
/// Complex geometries (e.g. a surface) are not implemented.
/// 
/// 
/// 
/// GeometryObject is the implementation base class for all types in the library.
/// It holds an ID (an internal ID) and name (for the use of the end users) members.
/// 
/// CAUTION FOR STATIC ID COUNTER:
///   GeometryObject stores a static member to hold the last used ID for any object.
///   An important issue to note is that the non-static ID of an object is coppied
///   with the default copy and move operations.
///   Hence, default copying of an object results with two objects having the same ID.
///   This is solved easily by user defined copy ctor and assignment functions.
///   The problem here is the temporary objects.
///   In the geometrical operations many temporary objects are created.
///   For example, creating a circle from three points generates lines and axes which are temporary.
///   The static ID counter is incremented firstly for the temporary objects and then for the circle object.
///   The temporaries are deleted when the circle ctor reaches the end
///   and the static ID counter is decremented for them.
///   Suppose at the beginning of the circle ctor, the static ID counter is 100
///   and suppose in the ctor we created 3 temporary objects.
///   Hence, the ID for the new circle object will be 104
///   but the static ID counter will be 101.
///   Hence, we need to inform the GeometryObject class whether the new object is a temporary or not.
///   THIS WILL BE IMPLEMENTED LATER.
/// 
/// Additionally, the library contains two static tolerance values to be used in the calculations:
///     GeometryParameters::TOLERANCE_GENERAL and GeometryParameters::TOLERANCE_SENSITIVE
/// The use of the tolerance consists of two cases:
///     1. To eliminate any kind of computational errors (e.g. truncation errors),
///     2. To be able to perform approximate calculations.
///        For example, intersection of two line may not exist theoritically
///        but an approximate point can be found.
///        A tolerance value is required for such approximations.
/// 
/// 
/// 
/// ReferenceObject is the base class for CS dependent objects (i.e. points and vectors).
/// It owns a CS member.
/// The geometry basically defined wrt to coordinate systems (CSs) in order to
///   1. simplify the tracebility of the objects
///   2. switch between spaces, especially 3D to 2D (or 2D to 3D)
/// The 1st functionality is a fundamental issue in engineering applications.
/// For example, an assembly of bodies is defined in a global CS
/// while each body has its own CS.
/// The 2nd functionality is similar to the 1st one.
/// Its benefit is more clear when it comes to switching between 2D and 3D spaces.
/// All CAE software (e.g. Catia) supports switching to 2D space.
/// This library can be utilized in this respect.
/// 
/// The z dimension (i.e. coord for a point and component for a vector) is zero for 2D objects by default.
/// However, the object does not have to be defined wrt the global CS.
/// If a CS other than the global CS is defined as the reference CS of a 2D object,
/// the object has x and y dimensions but no z-dimension wrt that CS.
/// 
/// Reference CS to global CS (or vice versa) transformations are supported.
/// 
/// Global CS is a singleton class.
/// See GlobalCoordSystem.hxx for the details
/// 
/// 
/// 
/// Axis, Line, Circle and Plane classes inherit from the base class (GeometryObject)
/// and do not have 2D and 3D types (e.g. Axis2D).
/// Actually, only the classes inheritting from ReferenceObject have 2D and 3D types.
/// The problem is not 2D/3D types but the reference CS.
/// An Axis cannot have a reference CS
/// because it has two members (point and vector)
/// and the reference CSs of the two may not be the same.
/// This can be satisfied as a precondition in the ctors of Axis
/// but the reference CSs of the point and vector members can be modified
/// after the Axis object instantiation.
/// Hence, setReferenceCoordSystem method of ReferenceObject shall be removed
/// in order for Axis to have a reference CS
/// But this solution is not preferable.
/// Hence, the types with more than one ReferenceObject members (Axis, Line, Circle and Plane)
/// do not have a reference CS and 2D/3D types
/// and inherit from the root class (GeometryObject).
/// Instead, they have three member functions:
/// is2D, is3D and getCommonReferenceCoordSystem.
/// 
/// 
/// 
/// The objects in the library are defined in an implementation hyerarchy.
/// The slicing problem that comes with the inheritance is
/// solved by using pointers and references.
/// THE CLIENTS OF THE LIBRARY SHOULD PAY ATTENTION ON THIS BASIC RULE.
/// 
/// 
/// 
/// 
/// 
/// author: baris.albayrak.ieee@gmail.com
/// github: https://github.com/BarisAlbayrakIEEE/cpp.git
/// </summary>

#pragma warning(disable : 4290)

#ifndef _GeometryObject_HeaderFile
#define _GeometryObject_HeaderFile

#define _USE_MATH_DEFINES
#include <cmath>
#include <string>
#include <array>
#include <vector>
#include <map>
#include <limits>
#include <memory>
#include <utility>
#include <type_traits>
#include <boost/type_index.hpp>
#include <boost/algorithm/string.hpp>

#ifndef _GeometryParameters_HeaderFile
#include "GeometryParameters.hxx"
#endif
#ifndef _GeometryMath_HeaderFile
#include "GeometryMath.hxx"
#endif
#ifndef _GeometryException_HeaderFile
#include "GeometryException.hxx"
#endif
#ifndef _Macros_HeaderFile
#include "Macros.h"
#endif

namespace GeometryNamespace {
	class GeometryObject;
	class GeometryException;
	class ReferenceObject;
	class CoordSystem;
	class GlobalCoordSystem;
	class PointBase;
	class Point2D;
	class Point3D;
	class VectorBase;
	class Vector2D;
	class Vector3D;
	class Axis;
	class Line;
	class Circle;
	class Plane;

	class GeometryObject
	{
		// Members
		static long int c_IDCounter;
		std::string c_name = "";
		long int c_ID = 0;

	protected:
		// ctor / dtor / operators
		GeometryObject() noexcept;

	public:
		GeometryObject(const GeometryObject& rhs);
		GeometryObject& operator=(const GeometryObject& rhs);
		GeometryObject(GeometryObject&& rhs) noexcept = default;
		GeometryObject& operator=(GeometryObject&& rhs) noexcept = default;
		virtual ~GeometryObject();

		inline bool operator==(const GeometryObject&) const { return true; }; // Exclude ID, name and tolerance values
		inline bool operator!=(const GeometryObject&) const { return true; }; // Exclude ID, name and tolerance values

		inline std::string getName() const noexcept { return c_name; };
		inline long int getID() const { return c_ID; };
		inline void setName(const std::string& theName) { c_name = theName; }; // Lvalue setter
		inline void setName(std::string&& theName) { c_name = std::move(theName); }; // Rvalue setter
		inline void setID(const long int& theID) { c_ID = theID; };

	protected:
		// Methods
		static bool inspectReferenceCoordSystems(
			ARGCOPY(ReferenceObject) theReference0,
			ARGCOPY(ReferenceObject) theReference1);

		void setIDName();
		static void incrementID();
		static void decrementID();
		template<typename T>
		static T Clone(const T& arg);
		template<typename T>
		inline std::string getTypeName(T&&) const
        {
            using boost::typeindex::type_id;

            std::string prettyName = type_id<T>().pretty_name();
            std::vector<std::string> splits;
            boost::split(splits, prettyName, boost::is_any_of("\t "));
			std::string outType = splits[1];
			if (outType == "") {
				return "GeometryObject";
			}
			return outType;
        }
	};
}

#endif
